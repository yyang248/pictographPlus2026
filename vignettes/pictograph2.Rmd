---
title: "PICTograph"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PICTograph}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
# library(pictograph2)
# library(dplyr)

setwd("~/JHU/scripts/R/pictograph2")
library(devtools)
load_all()
library(UpSetR)

```

## 1. Introduction

This tutorial walks through how to run PICTograph2 on toy examples. PICTograph2 infers the clonal evolution of tumors from single or multi-region sequencing data. The tool models uncertainty of mutation cellular fraction (MCF) in small somatic mutations (SSMs) and copy number alterations (CNAs), assigning SSMs and CNAs to subclones using a Bayesian hierarchical model, and reconstruct tumor evolutionary trees that are constrained based on principles of lineage precedence, sum condition, and optionally by sample-presence. The inputs to PICTograph2 are variant ("alt allele") read counts of SSMs, sequencing depth at the SSM loci, and the somatic CNA of the tumor genome. Tumor purity and the number of mutant alleles (multiplicity) are optional parameters. If multiple tumor samples are considered, an option is available to restrict the number of possible evolutionary trees by partitioning mutations according to sample presence. PICTograph2 summarizes the posterior distributions of the mutation cluster assignments and the MCFs for each cluster by the mode. The estimates of cluster MCFs are then used to determine the most probable trees. Multiple trees that share the same score can be summarized as an ensemble tree, where edges are weighted by their concordance among constituent trees in the ensemble.

## 2. Input data

Pictograph2 takes input data in multiple formats for flexible user inputs:

1) A single csv file that contains SSM and CNA information
2) Two csv files, one for SSM and one for CNA
3) Three csv files, one for ssm, one for CNA, and one for germline heterozygous single nucleotide variants (SNV)

### 2.1. The first option is to provide a single csv file that contains at least columns named "sample", "mutation", "total_reads", "alt_reads", "tumor_integer_copy_number", and "cncf". Users can also provide an optional column "major_integer_copy_number" that provides the information of the integer copy number of the major allele. If "major_integer_copy_number" is not provided, it will be estimated using an internal function built in the package. Another optional column is "purity" column that provides the information of normal contamination of a sample. Putiry of 0.8 wil be used if not provided.

```{r raw_data format}
head(read.csv(system.file('extdata/examples/example1_snv.csv', package = 'pictograph2')))
head(read.csv(system.file('extdata/examples/example2_snv.csv', package = 'pictograph2')))
head(read.csv(system.file('extdata/examples/example2_snv_with_purity.csv', package = 'pictograph2')))
```
### 2.2. The second option is to provide the SSM read counts and copy number alterations (CNA) in two separate files. In this case, the SSM file should contain columns "sample", "mutation", "total_reads", "alt_reads", "chrom", "start", and "end". The "purity" column with be optional. The CNA file should contain columns "sample", "chrom", "start", "end", "tcn" and "baf".

```{r}
head(read.csv(system.file('extdata/examples/example3_snv.csv', package = 'pictograph2')))
head(read.csv(system.file('extdata/examples/example3_cna.csv', package = 'pictograph2')))
```

### 2.3. In the absence of the baf column, users should provide an additional file that contains the count of the heterozygous germline SNVs that has the information about the "chroms", the "position" of the germline heterozygous SNV, "ref" and "alt" allele, and the reference and altenative reads counts in germline (normal) sample as well as all other samples. Note: the sample name should matched the sample name used in the SSM and CNA file.

```{r}
head(read.csv(system.file('extdata/examples/example4_snv.csv', package = 'pictograph2')))
head(read.csv(system.file('extdata/examples/example4_cna.csv', package = 'pictograph2')))
head(read.csv(system.file('extdata/examples/example4_SNP.csv', package = 'pictograph2')))
```

## 3. Run an automated pipeline of the tool using the function mcmcMain. The only required user input is the "mutation_file", along with the "copy_number_file" and "SNV_file" if using format 2 or 3 mentioned above. Users can specify the destination of output files using "outputDir" option. If the outputDir is not specified, output files will be stored in the current working directory.

```{r input_data}
mcmcMain(mutation_file=system.file('extdata/examples/example1_snv.csv', package = 'pictograph2'),
         copy_number_file=NULL,
         SNV_file=NULL,
         outputDir=system.file('extdata/examples/output', package = 'pictograph2'))
```

## 3. Clustering mutations and estimating CCFs

The first step of evolutionary analysis is clustering mutations and estimating their cancer cell fractions (CCFs). This is comprised of three steps:

a.  By default, for individuals with multiple tumor samples, the mutation data is initially split into sets by sample-presence. Users can choose not to apply sample-presence by setting the one_box parameter in the clusterSep function to 'T'. For individuals with many samples and few mutations, this may be preferable. Next, PICTograph estimates the joint posterior of CCFs and cluster assignments by Markov chain Monte Carlo (MCMC) across a range of possible values for the number of clusters, $K$
b.  Selecting the best $K$ for each mutation set
c.  Merging the best chains of each mutation set

### 3a. Run clustering and CCF estimation separately for each mutation set

In toy example, we run a short MCMC chain with only 1000 iterations (`n.iter`), burn-in of 100 (`n.burn`), and no thinning (`thin`). In practice, we recommend running the MCMC for longer e.g. 10,000 iterations, burn-in of 1000, and thinning by 10. By default, PICTograph separates mutations into sets by sample-presence patterns, and clusters mutations separately within each set. The maximum number of clusters can be set with the `max_K` option. To turn off the sample-presence separation, set the `one_box` option to `T`. To run the MCMC chains in parallel, set the `mc.cores` option to the number of desired cores.

```{r cluster, eval = FALSE}
all_set_results <- clusterSep(input_data,
                              n.iter = 1000, n.burn = 100, thin = 1,
                              max_K = 5, one_box = T, mc.cores = 2)
```

This gives us a list with results for each mutation set, which contains `all_chains`, `BIC`, `best_chains`, and `best_K`.

`all_chains` is a list of MCMC chains for each value of $K$ tested. For each $K$, there are chains for cluster CCF (`w_chain`), mutation cluster assignments (`z_chain`), and simulated variant read counts (`ystar_chain`) for posterior predictive distributions.

`BIC` is a table of the BIC for each $K$ assessed.

As default, PICTograph chooses the $K$ with the lowest BIC. The MCMC chains for this chosen $K$ are under `best_chains` and the $K$ chosen is listed under `best_K`.

```{r cluster_res}
str(all_set_results, give.attr = F, max.level = 4)
```

### 3b. Select the best number of clusters, $K$, for each mutation set

From `all_set_results`, BIC values for all $K$ assessed in each mutation set can be visualized using `plotBIC`. The minimum, elbow, and knee points are marked.

```{r plot_bic, fig.height = 3, fig.width = 7}
plotBIC(all_set_results)
```

Use `writeSetKTable` to generate a table with the K at minimum, elbow, and knee points of the BIC plot for each mutation set. The default chosen_K is the minimum K among the three, but users can also adjust the chosen_K accordingly.

```{r set_choices}
set_k_choices <- writeSetKTable(all_set_results)
set_k_choices
```

We can extract the MCMC chains for the best $K$ of each mutation set using `collectBestKChains`. As default, PICTograph chooses the $K$ with the lowest BIC, and these chains will be automatically extracted. Users also have the option to specify the $K$ to choose for each mutation set by supplying a vector of integers to the parameter `chosen_K` in the same order as the listed sets in `all_set_results`.

```{r collect_best_chains}
best_set_chains <- collectBestKChains(all_set_results, chosen_K = set_k_choices$chosen_K)
str(best_set_chains, give.attr = F, max.level = 2)
```

### 3c. Merge results for all mutation sets

Finally, we can merge `best_set_chains` to obtain chains with the final mutation cluster numbering and correct mutation indices (original order provided in input data).

```{r merge, eval = FALSE}
chains <- mergeSetChains(best_set_chains, input_data)
```

### Visualizing clustering and CCF estimation results

Traces for CCF chains can be visualized to check for convergence.

```{r ccf_trace, fig.height = 6, fig.width = 6}
plotChainsCCF(chains$w_chain)
```

The posterior distribtuion of cluster CCFs can be visualized as violin plots. The number of mutations assigned to each cluster is listed in brackets after the cluster name.

```{r ccf_violin, fig.height = 4, fig.width = 6}
plotCCFViolin(chains$w_chain, chains$z_chain, indata = input_data)
```

We can also visualize the posterior probabilities of mutation cluster assignments and determine the most probable cluster assignments. In this toy example, there is high concordance of the cluster assignments of mutations across the MCMC chain.

```{r cluster-assignments, fig.height = 6, fig.width = 5}
plotClusterAssignmentProbVertical(chains$z_chain, chains$w_chain)
```

We can write tables for estimated cluster CCFs and mutation cluster assignments.

```{r tables}
writeClusterCCFsTable(chains$w_chain)
writeClusterAssignmentsTable(chains$z_chain, Mut_ID = input_data$MutID)
```

## 4. Tree inference

We can then use the mutation cluster CCF estimates for tree inference. We first estimate the possible edges by applying lineage precedence filters to order the clusters on a tree. The `lineage_precedence_thresh` option allows relaxation of lineage precedence constraints so that the child cluster CCF can exceed a parent cluster CCF by a small amounts. The default of `lineage_precedence_thresh` is 0.1. Filtered edges are stored in an object named `graph_G`.

Next, we enumerate this constrained tree space, and apply a filter based on the sum condition. The `sum_filter_thresh` option allows relaxation of sum condition constraints so that the sum of child cluster CCFs at a branch point can exceed the parent cluster CCF by a small amount. The default of `sum_filter_thresh` is 0.2.

```{r generate-all-tree}
generateAllTrees(chains$w_chain, lineage_precedence_thresh = 0.1, sum_filter_thresh = 0.2)
```

All spanning trees given by the possible edges that pass the sum condition filter are stored in `all_spanning_trees`.

```{r tree-space}
length(all_spanning_trees)
all_spanning_trees
```

We then calculate a fitness score for all the trees that have passed our filtering and identify the highest scoring tree.

```{r tree-scoring,  fig.height = 4, fig.width = 5}
# calculate SCHISM fitness score for all trees
scores <- calcTreeScores(chains$w_chain, all_spanning_trees)
scores
# highest scoring tree
best_tree <- all_spanning_trees[[which.max(scores)]]
# plot tree
plotTree(best_tree)
```

In this toy example, there is only one tree with the maximum score. In some cases, multiple trees will share the maximum score. We can plot an ensemble tree to visualize the evolutionary relationships (edges) that are shared among multiple trees. In the ensemble tree, edges are weighted by the number of trees in which they are represented. To illustrate this plotting function, here we plot an ensemble of the two trees that were enumerated. The solid black edges represent those supported in both trees.

```{r ensemble-tree,  fig.height = 4, fig.width = 5}
plotEnsembleTree(all_spanning_trees)
```

## Subclone proportions

For individuals with multiple available tumor samples, the proportion of each subclone in each sample can be calculated using `calcSubcloneProportions`. This is calculated using the estimated cluster CCFs and the ordering of clusters on the best scoring tree. Two available options for visualizing subclone proportions are pie charts using `plotSubclonePie` and stacked bar graphs using `plotSubcloneBar`.

```{r subclone-props, fig.height = 4, fig.width = 5}
subclone_props <- calcSubcloneProportions(w_mat, best_tree)
plotSubclonePie(subclone_props, sample_names = colnames(input_data$y))
plotSubcloneBar(subclone_props, sample_names = colnames(input_data$y))
```

We can force the cluster CCF estimates to comply with the sum condition for a given tree using `forceCCFs`.

```{r force_ccfs,  fig.height = 4, fig.width = 5}
fixed_w_mat <- forceCCFs(w_mat, best_tree)
fixed_subclone_props <- calcSubcloneProportions(fixed_w_mat, best_tree)
plotSubcloneBar(fixed_subclone_props)
```

Subclone proportions can also be calculated for the edges of an ensemble tree that are shared by all summarized trees (backbone). For this example ensemble tree, the "backbone" is made up of the root node and nodes 1, 2, 3, and 5, which are connected by thick black edges.

```{r backbone,  fig.height = 4, fig.width = 5}
selected_trees <- all_spanning_trees
plotEnsembleTree(selected_trees)

backbone <- bind_rows(selected_trees) %>%
  group_by(edge) %>%
  mutate(count = n()) %>%
  ungroup() %>%
  filter(count == length(selected_trees)) %>%
  distinct() %>%
  select(edge, parent, child)

fixed_w_mat_backbone <- forceCCFs(w_mat, backbone)
fixed_w_mat_backbone[is.na(fixed_w_mat_backbone)] = 0

backbone_subclone_props <- calcSubcloneProportions(fixed_w_mat_backbone, backbone)
plotSubcloneBar(backbone_subclone_props)
```
